# python 基础语法 
- python中的“不等于None”不能写"!=None"，要写"is not None"

**python中is比较的是两个对象的内存地址，而==是调用类的__eq__函数比较的。而且在python里面，None是一个单例对象，
所有None内存地址都是一样的，因此用is比较最准确。用==的话，会根据具体的__eq__函数确定结果。那为什么数字的比较都是用
==，因为数字的比较比的是数字本身是否相等，而不是比较内存地址，而两个数字相同的对象内存可能不同**。比如下面的代码：
```
In [2]: class Student:
   ...:     def __eq__(self, other):
   ...:         return True
   ...:

In [3]: s = Student()

In [4]: s is None
Out[4]: False

In [5]: s == None
Out[5]: True

In [6]: id(s)
Out[6]: 2636099000136

In [7]: id(None)
Out[7]: 1471456400
```

- if a is not None 和 if a的区别？

## 深拷贝和浅拷贝

python的赋值语句 b = a 使对象a有了一个**别名**b。这时对b的操作都会影响到a。
```
In [1]: a = [1, 2, 3]

In [2]: b = a

In [3]: b.append(4)

In [4]: b
Out[4]: [1, 2, 3, 4]

In [5]: a
Out[5]: [1, 2, 3, 4]

In [6]: b[0] = 0

In [7]: b
Out[7]: [0, 2, 3, 4]

In [8]: a
Out[8]: [0, 2, 3, 4]
```


这里的拷贝指的是**被拷贝对象的一个副本**，而不是一个**别名**。

如下面的**b=list(a)或b=copy.copy()是一个浅拷贝**对浅拷贝得到的对象添加或删除元素对原对象不会有影响，改变浅拷贝得到的对象的第0个维度，对原对象也没有影响。

**改变浅拷贝得到的对象第0维度之外的元素，可以改变原对象**

```
In [9]: a = [1, 2, 3]

In [10]: b = list(a) # b = copy.copy()

In [11]: b.append(4)

In [12]: b
Out[12]: [1, 2, 3, 4]

In [13]: a
Out[13]: [1, 2, 3]

In [14]: b[0] = 0

In [15]: b
Out[15]: [0, 2, 3, 4]

In [16]: a
Out[16]: [1, 2, 3]


In [17]: a = [[1,2], [3, 4]]

In [18]: b = list(a)

In [19]: b[0][0] = 5

In [20]: b
Out[20]: [[5, 2], [3, 4]]

In [21]: a
Out[21]: [[5, 2], [3, 4]]
```

**b = copy.deepcopy(a)是一个深拷贝**。深拷贝得到的对象和原对象无关，任意修改都不会影响到原对象。
但是深拷贝占的空间更大，这是其缺点。

## python的输入

[参考网站](https://www.jianshu.com/p/6f14ca3290ee)


# python类中的super方法

[Python—子类构造函数调用super().__init__()](https://blog.csdn.net/paopaohll/article/details/83063349)

[详解类class的继承、__init__初始化、super方法](https://blog.csdn.net/brucewong0516/article/details/79121179)

# Python中pass、continue、break、exit()的区别

pass :不做任何事情，只起到占位的作用

continue: 跳出本次循环

break：结束循环

exit()：结束整个程序

# python的装饰器、生成器和迭代器

## 装饰器
装饰器本质上是一个函数，它可以让其他函数在不需要做任何代码变动的前提下增加额外
功能。装饰器的返回值也可以是一个函数对象。概括地讲，装饰器是为了给已经存在的
对象增加额外的功能。常用的场景有：插入日志、权限校验等。

## 迭代器
对于list、string、tuple、dict等这些容器对象,使用for循环遍历是很方便的。在后台for语句对容器对象调用iter()函数。iter()是python内置函数。 
**iter()函数会返回一个定义了next()方法的迭代器对象，它在容器中逐个访问容器内的元素**。next()也是python内置函数。在没有后续元素时，
next()会抛出一个StopIteration异常，通知for语句循环结束。

迭代器是用来帮助我们记录每次迭代访问到的位置，当我们对迭代器使用next()函数的时候，迭代器会向我们返回它所记录位置的下一个位置的数据。
实际上，在使用next()函数的时候，调用的就是迭代器对象的_next_方法（Python3中是对象的_next_方法，Python2中是对象的next()方法）。
所以，我们要想**构造一个迭代器，就要实现它的_next_方法**。但这还不够，python要求**迭代器本身也是可迭代的，所以我们还要为迭代器实现
_iter_方法**，而_iter_方法要返回一个迭代器，迭代器自身正是一个迭代器，所以**迭代器的_iter_方法返回自身self即可**。


## 生成器

作用：延迟操作。也就是在需要的时候才产生结果，不是立即产生结果。

注意：
- 生成器是只能遍历一次的。
- 生成器是一类特殊的迭代器。

**第一类：生成器函数**：还是使用 def 定义函数，但是，使用yield而不是return语句返回结果。yield语句一次返回一个结果，在每个结果中间，
挂起函数的状态，以便下次从它离开的地方继续执行。

**第二类：生成器表达式**：类似于列表推导，只不过是把一对大括号[]变换为一对小括号()。但是，生成器表达式是按需产生一个生成器结果对象，
要想拿到每一个元素，就需要循环遍历。

为什么要使用生成器？因为效率。
使用生成器表达式取代列表推导式可以同时节省 cpu 和 内存(RAM)。如果你构造一个列表(list)的目的仅仅是传递给别的函数,比如 传递给tuple()
或者set(), 那就用生成器表达式替代吧!









