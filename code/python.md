# python 基础语法 
- python中的“不等于None”不能写"!=None"，要写"is not None"

**python中is比较的是两个对象的内存地址，而==是调用类的__eq__函数比较的。而且在python里面，None是一个单例对象，
所有None内存地址都是一样的，因此用is比较最准确。用==的话，会根据具体的__eq__函数确定结果。那为什么数字的比较都是用
==，因为数字的比较比的是数字本身是否相等，而不是比较内存地址，而两个数字相同的对象内存可能不同**。比如下面的代码：
```
In [2]: class Student:
   ...:     def __eq__(self, other):
   ...:         return True
   ...:

In [3]: s = Student()

In [4]: s is None
Out[4]: False

In [5]: s == None
Out[5]: True

In [6]: id(s)
Out[6]: 2636099000136

In [7]: id(None)
Out[7]: 1471456400
```

- if a is not None 和 if a的区别？

## 深拷贝和浅拷贝

python的赋值语句 b = a 使对象a有了一个**别名**b。这时对b的操作都会影响到a。
```
In [1]: a = [1, 2, 3]

In [2]: b = a

In [3]: b.append(4)

In [4]: b
Out[4]: [1, 2, 3, 4]

In [5]: a
Out[5]: [1, 2, 3, 4]

In [6]: b[0] = 0

In [7]: b
Out[7]: [0, 2, 3, 4]

In [8]: a
Out[8]: [0, 2, 3, 4]
```


这里的拷贝指的是**被拷贝对象的一个副本**，而不是一个**别名**。

如下面的**b=list(a)或b=copy.copy()是一个浅拷贝**对浅拷贝得到的对象添加或删除元素对原对象不会有影响，改变浅拷贝得到的对象的第0个维度，对原对象也没有影响。

**改变浅拷贝得到的对象第0维度之外的元素，可以改变原对象**

```
In [9]: a = [1, 2, 3]

In [10]: b = list(a) # b = copy.copy()

In [11]: b.append(4)

In [12]: b
Out[12]: [1, 2, 3, 4]

In [13]: a
Out[13]: [1, 2, 3]

In [14]: b[0] = 0

In [15]: b
Out[15]: [0, 2, 3, 4]

In [16]: a
Out[16]: [1, 2, 3]


In [17]: a = [[1,2], [3, 4]]

In [18]: b = list(a)

In [19]: b[0][0] = 5

In [20]: b
Out[20]: [[5, 2], [3, 4]]

In [21]: a
Out[21]: [[5, 2], [3, 4]]
```

**b = copy.deepcopy(a)是一个深拷贝**。深拷贝得到的对象和原对象无关，任意修改都不会影响到原对象。
但是深拷贝占的空间更大，这是其缺点。

## python的输入

[参考网站](https://www.jianshu.com/p/6f14ca3290ee)


# python类中的super方法

[Python—子类构造函数调用super().__init__()](https://blog.csdn.net/paopaohll/article/details/83063349)

[详解类class的继承、__init__初始化、super方法](https://blog.csdn.net/brucewong0516/article/details/79121179)

# Python中pass、continue、break、exit()的区别

pass :不做任何事情，只起到占位的作用

continue: 跳出本次循环

break：结束循环

exit()：结束整个程序

# python的装饰器、生成器和迭代器

## 装饰器
装饰器本质上是一个函数，它可以让其他函数在不需要做任何代码变动的前提下增加额外
功能。装饰器的返回值也可以是一个函数对象。概括地讲，装饰器是为了给已经存在的
对象增加额外的功能。常用的场景有：插入日志、权限校验等。

## 迭代器
对于list、string、tuple、dict等这些容器对象,使用for循环遍历是很方便的。在后台for语句对容器对象调用iter()函数。iter()是python内置函数。 
**iter()函数会返回一个定义了next()方法的迭代器对象，它在容器中逐个访问容器内的元素**。next()也是python内置函数。在没有后续元素时，
next()会抛出一个StopIteration异常，通知for语句循环结束。

迭代器是用来帮助我们记录每次迭代访问到的位置，当我们对迭代器使用next()函数的时候，迭代器会向我们返回它所记录位置的下一个位置的数据。
实际上，在使用next()函数的时候，调用的就是迭代器对象的_next_方法（Python3中是对象的_next_方法，Python2中是对象的next()方法）。
所以，我们要想**构造一个迭代器，就要实现它的_next_方法**。但这还不够，python要求**迭代器本身也是可迭代的，所以我们还要为迭代器实现
_iter_方法**，而_iter_方法要返回一个迭代器，迭代器自身正是一个迭代器，所以**迭代器的_iter_方法返回自身self即可**。


## 生成器

作用：延迟操作。也就是在需要的时候才产生结果，不是立即产生结果。

注意：
- 生成器是只能遍历一次的。
- 生成器是一类特殊的迭代器。

**第一类：生成器函数**：还是使用 def 定义函数，但是，使用yield而不是return语句返回结果。yield语句一次返回一个结果，在每个结果中间，
挂起函数的状态，以便下次从它离开的地方继续执行。

**第二类：生成器表达式**：类似于列表推导，只不过是把一对大括号[]变换为一对小括号()。但是，生成器表达式是按需产生一个生成器结果对象，
要想拿到每一个元素，就需要循环遍历。

为什么要使用生成器？因为效率。
使用生成器表达式取代列表推导式可以同时节省 cpu 和 内存(RAM)。如果你构造一个列表(list)的目的仅仅是传递给别的函数,比如 传递给tuple()
或者set(), 那就用生成器表达式替代吧!

# python的多线程和多进程
多线程是multi threading，而多进程是 multi processing。线程与进程的区别我们在操作系统中已经学习过了，简而言之，进程可以包含多个线程，而线程是进程的一个实体。开线程的代价比开进程的代价小，而且便于通信，但是多进程更稳定一些，毕竟一个线程crash了，整个进程都会挂，而多进程之间通常是独立的。

区别：  
（1）线程共享内存空间；进程的内存是独立的

（2）同一个进程的线程之间可以直接交流；两个进程想通信，必须通过一个中间代理来实现

（3）创建新线程很简单； 创建新进程需要对其父进程进行一次克隆

（4）一个线程可以控制和操作同一进程里的其他线程；但是进程只能操作子进程

（5）改变主线程（如优先权），可能会影响其它线程；改变父进程，不影响子进程


# 垃圾回收机制
就python而言，主要采用的是常见的引用计数机制，同时结合标记-清除和分代收集两种机制。python中一切皆对象，每一个Python对象都有一个引用计数器，用于记录有多少其他对象指向(引用)这个对象。**当引用计数变为0时，会回收对象释放内存空间。**

引用计数法有很明显的优点：

- 实现简单

- 实时性：一旦没有引用，内存就直接释放了。不用像其他机制等到特定时机。实时性还带来一个好处：处理回收内存的时间分摊到了平时。

但同时存在非常显著的的缺点：

- 维护引用计数消耗资源，维护引用计数的次数和引用赋值成正比，而不像mark and sweep等基本与回收的内存数量有关。

- 无法解决循环引用的问题。A和B相互引用而再没有外部引用A与B中的任何一个，它们的引用计数都为1，但显然应该被回收。

**为解决上面2个问题，python又引入了两种GC机制**：  
- 标记清除（Mark—Sweep）』算法是一种基于追踪回收（tracing GC）技术实现的垃圾回收算法。它分为两个阶段：第一阶段是标记阶段，GC会把所有的『活动对象』打上标记，第二阶段是把那些没有标记的对象『非活动对象』进行回收。    
- 分代回收是一种以空间换时间的操作方式。  





