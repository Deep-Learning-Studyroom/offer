# C++和C的区别？
C++是面向对象的编程语言，C是面向过程的

# C++基础语法

## cin、cout对象的多个方法
- cin.ignore()  忽略前n个字符

- cin.getline()

- cin.get()   从缓冲流里面提取一个字符

- cin.peek()  从缓冲流里拿一个字符，然后把它放回去

- cin.gcount()

- cin.read()

- cout.precision()

- cout.width()

## 函数的重载(overloading)  

**所谓函数重载的实质是用同样的名字再定义一个有着不同参数但有着同样用途的函数**。对函数进行重载，可以简化编程工作和提高代码的可读性。
**重载并不是一个面向对象的特征，只是简化编程工作的一种方案。**目的是为了方便对不同数据类型进行同样的处理。

注意重载和覆盖的区别：如果两个函数的函数名、参数和返回值都相同，那么是函数的覆盖。

## 复杂的数据类型（数组、指针和结构）

数组的定义：
```c++
int name[10]; //定义一个长度为10的整形数组
```
例子：见C++程序实例.md中的Example-10

字符串：std::string

string是C++标准库定义的一个对象，其内建功能非常多。
```c++
//先定义三个string变量
string str1 = "hello";
string* str2 = new string("hello");
string str3 = "world";
```
- 获取字符串长度  **int length = str1.length();**

- 提取字符串  
```c++
//获取字符串的第一个字符
string::const_iterator it = str1.begin();
cout << *it << endl;
cout << endl;

//获取字符串的最后一个字符
it = str1.end();//end是指向最后一个字符后面的元素，而且不能输出,所以cout << *it << endl;这样输出会报错
it--;
cout << *it << endl;
cout << endl;
```
- 比较字符串  ****

```c++
if (str1 < str3)
{
	cout << "字符串的比较：" << "str1<str2" << endl;
}
cout << endl;
```
- 添加字符串

- 搜索字符串  **str1.find('a', 2)**,从位置2开始，查找'a'，返回首次匹配的位置，失败则返回-1；**str1.rfind('a', 7)**，从指定位置向前查找，直到串首。

- 倒置字符串  **reverse(str1.begin(), str1.end())**

- 字符串转数组  
```c++
string c = "abc123";
char *d = new char[20];
strcpy(d, c.c_str());//因为这里没有直接赋值，所以指针类型可以不用const char *
```
## 指针
指针是C和C++中最重要的数据类型之一。

想了解指针，必须先了解**地址**，每一个地址对应一个字节（一个字节8位）。

**寻址：**对于变量可以用两种方法来对他进行索引

- 通过变量名

- 通过地址。**一个重要的操作符，“取址”操作符：“&”，它的作用是获取变量的地址**。变量的地址在程序执行期间是不会发生变化的，
这是各个系统一个普遍的要求。不过，同一个程序不同时间加载到内存中，同一个变量的地址是会改变的。
```c++
int var = 123;
std::cout << "Address is:" << &var;
```
**地址是计算机内存中的某个位置，而指针是专门用来存放地址的特殊类型变量。**

一般情况下，我们用下边的方式来声明指针变量。

- type *pointerName;
- int *pointerName1 = &a1;
- 例如
```c++
int *p;
int pp = 123;
p = &pp;
```
- 注意这条语句 int *p1, p2, p3;这里声明的指针变量只有一个：p1，而p2和p3都是整型变量。

- 创建指针时，空格放在哪里都是没关系的，下边的语句都可以接受
	- int *p1;
	- int * p1;
	- int* p1;

- 指针前面的数据类型指的是指针指向的数据类型

允许void类型的指针  void *p;对一个无类型指针进行解引用前，必须先把它转换为一种适当的数据类型。

星号的两种用途：  
- 第一种是用于创建指针：int *myPointer = &myInt;  
- 第二种是对指针进行解引用：*myPointer = 3998; 这句的意思是对myInt赋值3998.

C++允许多个指针有同样的值

## 指针和数组

数组在计算机中是以一组连续的内存块保存的。**数组的名字其实也是一个指针，指向数组的基地址，就是第一个元素的地址。**
下面两句话做了同样的事情：  
- int *p1 = &myArray[0];  
- int *p2 = myArray;

已经得到数组的基地址的指针p1，如何访问数组的其他元素？p1++，这个运算并不是将地址值简单+1处理，
它是按照指向的数组的数据类型来递增的，也就是+sizeof(int)。

## 结构

**结构(struct)是一种由程序员定义的、由其他变量类型组合而成的数据类型**。定义一个结构的基本语法是
```
struct name
{
	type varName1;
	type varName2;
}; //注意，这里有个分号！
```
当需要处理一些具有多种属性的数据时，结构往往是很好的选择。C++对于一个结构所能包含的变量的个数是没有限制的，
结构的变量成为成员。用"."对结构成员进行赋值。**在C和C++里，指针是无所不能的，也可以指向结构**。

如何通过指针的解引用指向该结构的各个成员？（或者说是通过指针访问各个成员的值）  
- 创建一个指向该结构的指针：FishOil *pJiayu = &Jiayu;  
- 注意，指针的类型必须与指向的地址的变量类型一致，所以pJiayu指针的类型也是FishOil  
- 指针解引用来访问相应的变量值  (*pJiayu).name = "fahiuf";  
- 另一种方法，pJiayu -> name = "fahiuf";std::cout << pJiayu -> name;  

## 传值、传址和传引用

**在默认的情况下，参数只能以值传递的方式给函数。即，被传递到函数的只是变量的值，而不是变量本身**  
**绕开“值传递”的第一种方法是向函数传递变量的地址，也就是说只需要在变量前面加一个“取地址”操作符&就可以了**  
**注意，如果传过去的是地址，在函数中必须要通过“*”对指针进行解引用，除非你有其他用途**
```c++
void changeAge(int age, int newAge) // 传值
{
	age = newAge;
}
int age = 20;
changeAge(age, age+1) // age还是20
```

```c++
void changeAge(int *age, int newAge) // 传址，这里需要把地址解引用
{
	*age = newAge;
}
int age = 20;
changeAge(&age, age+1) // age变为21
```
**例子见Example-12**

引用传递和传址的目的是一样的，都是把地址传递给函数，但语法不通更加容易使用了

# C++的多态

## 重载、重写、重定义的的区别

### 1. 重载

​	函数重载是指在同一作用域内（**在同一个类中**），**函数名相同，参数列表不同**的一组函数，这组函数被称为重载函数。重载函数通常用来命名一组功能相似的函数，这样做减少了函数名的数量，避免了名字空间的污染，对于程序的可读性有很大的好处。比如说四则运算中的+函数，可以根据参数不同定义参数为int、str时的加法。被重载的函数不需要有virtual关键字，它们的返回值也有所不同。但调用函数时，会根据参数的类型选择执行哪一个函数。

### 2. 重写

重写就是override，是指派生类中定义基类中的虚函数，为多态服务。特征是重写的函数与基函数不在一个作用域中（基类和派生类），它们的函数名、函数参数类型、返回值类型都必须相同，但它们的访问修饰符可以不同（private、public、protected），且基类必须是**虚函数或纯虚函数**。举个例子，父亲要看电影、儿子也要看电影，但他们看完电影的反应是不一样的（但都得是一种类型的反应，比如说某句话，或者做某件事），他们的函数输入也必须都是电影。父亲看完后print 好看，儿子看完后print 难看，这就是一种虚函数的重写。在函数重写时，往往会加上override关键字声明，以防和重定义混淆。

### 3. 重定义

重定义也叫隐藏，重定义是指在不同作用域中，派生类定义了一个和基类函数名字相同、返回值可以不同、参数不同重定义函数。

- 当基类函数是虚函数时，若子类函数的参数与基类函数相同，那么它叫重写，若参数不同，那么它叫重定义。当基函数和子函数参数不同，并且子函数还用override关键字声明时，编译就会报错。
- 当基类函数不是虚函数时，无论参数是否相同，子类函数都算重定义。

## 虚函数、纯虚函数、静态联编、动态联编

### 1. 虚函数、静态联编、动态联编

- 静态联编是指在函数编译时就已确定要调用函数的哪个实现，而动态联编是指在函数执行时才确定调用函数的哪个实现，有些类似tf和pytorch的静态图和动态图。静态联编效率高，动态联编更灵活，**C语言中全都是静态联编**，这也可以说明C中没有对象的概念，也不存在灵活的多态。动态联编还需要和虚函数一起讲。

- 虚函数时为了满足多态的特性，在基类中定义的一种函数。当一个基类类型的指针指向一个派生类的对象时，会优先调用派生类对象中定义的虚函数，而不是基类中的虚函数。比如

```c++
class Cfather
{
public:
virtual void Eat(){cout<<"Im your father"<<endl;}
void Move(){cout<<"father can move, kid cant do it";}
private:
};
class CChild : public Cfather
{
public:
virtual void Eat(){cout<<"Im your kid"<<endl;}
private:
};
Cfather m_father;
CChild m_child;
Cfather *p ;  // 注意，此时指针类型是父类
p = &m_father ; //指向基类对象的父类类型指针
p->Eat();    //输出"Im your father"
p = &m_child;
p->Eat();    // 输出"Im your kid"
//如果子类没有重写此函数时，则还是调用父类中的
p->Move(); //输出 "father can move, kid cant do it"
```

在这里，指向子类对象的指针调用Eat函数时就是动态联编，直到运行时才根据对象m_child的类型确定调用哪个函数实现。

### 2. 纯虚函数

纯虚函数比较简单，类似于Java中的接口函数。它在基类中不允许被定义，但要求它的派生类必须实现纯虚函数，有纯虚函数的类也叫做**抽象类**（抽象类不能生成对象）。纯虚函数的意义在于它代表着一种抽象的对象，比如生物，生物可以由人、老虎等继承，但是它本身缺少实际的意义，所以生物会作为一个抽象类。要定义纯虚函数，只需要在虚函数的函数体后加一个“=0”即可，比如

```c++
class Creature{
      public:
          virtual void speak() = 0;//纯虚函数, print生物叫声，但“生物”本身是没有叫声的
}
class Dog{
  		public:
  				virtual void speak(){cout<<"汪汪汪！"<<endl;}
}
class Cat{
  		public:
  				virtual void speak(){cout<<"喵喵喵！"<<endl;}
}
```





