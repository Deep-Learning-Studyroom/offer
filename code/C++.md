本文对应的代码在同一文件夹下的"C++程序示例"中。

# C++和C的区别？
C++是面向对象的编程语言，C是面向过程的

# C++基础语法

## cin、cout对象的多个方法
- cin.ignore()  忽略前n个字符

- cin.getline()

- cin.get()   从缓冲流里面提取一个字符

- cin.peek()  从缓冲流里拿一个字符，然后把它放回去

- cin.gcount()

- cin.read()

- cout.precision()

- cout.width()

## 函数的重载(overloading)  

**所谓函数重载的实质是用同样的名字再定义一个有着不同参数但有着同样用途的函数**。对函数进行重载，可以简化编程工作和提高代码的可读性。
**重载并不是一个面向对象的特征，只是简化编程工作的一种方案。**目的是为了方便对不同数据类型进行同样的处理。

注意重载和覆盖的区别：如果两个函数的函数名、参数和返回值都相同，那么是函数的覆盖。

## 复杂的数据类型（数组、指针和结构）

数组的定义：
```c++
int name[10]; //定义一个长度为10的整形数组
```
例子：见C++程序实例.md中的Example-10

字符串：std::string

string是C++标准库定义的一个对象，其内建功能非常多。
```c++
//先定义三个string变量
string str1 = "hello";
string* str2 = new string("hello");
string str3 = "world";
```
- 获取字符串长度  **int length = str1.length();**

- 提取字符串  
```c++
//获取字符串的第一个字符
string::const_iterator it = str1.begin();
cout << *it << endl;
cout << endl;

//获取字符串的最后一个字符
it = str1.end();//end是指向最后一个字符后面的元素，而且不能输出,所以cout << *it << endl;这样输出会报错
it--;
cout << *it << endl;
cout << endl;
```
- 比较字符串  ****

```c++
if (str1 < str3)
{
	cout << "字符串的比较：" << "str1<str2" << endl;
}
cout << endl;
```
- 添加字符串

- 搜索字符串  **str1.find('a', 2)**,从位置2开始，查找'a'，返回首次匹配的位置，失败则返回-1；**str1.rfind('a', 7)**，从指定位置向前查找，直到串首。

- 倒置字符串  **reverse(str1.begin(), str1.end())**

- 字符串转数组  
```c++
string c = "abc123";
char *d = new char[20];
strcpy(d, c.c_str());//因为这里没有直接赋值，所以指针类型可以不用const char *
```
## 指针
指针是C和C++中最重要的数据类型之一。

想了解指针，必须先了解**地址**，每一个地址对应一个字节（一个字节8位）。

**寻址：**对于变量可以用两种方法来对他进行索引

- 通过变量名

- 通过地址。**一个重要的操作符，“取址”操作符：“&”，它的作用是获取变量的地址**。变量的地址在程序执行期间是不会发生变化的，
这是各个系统一个普遍的要求。不过，同一个程序不同时间加载到内存中，同一个变量的地址是会改变的。
```c++
int var = 123;
std::cout << "Address is:" << &var;
```
**地址是计算机内存中的某个位置，而指针是专门用来存放地址的特殊类型变量。**

一般情况下，我们用下边的方式来声明指针变量。

- type *pointerName;
- int *pointerName1 = &a1;
- 例如
```c++
int *p;
int pp = 123;
p = &pp;
```
- 注意这条语句 int *p1, p2, p3;这里声明的指针变量只有一个：p1，而p2和p3都是整型变量。

- 创建指针时，空格放在哪里都是没关系的，下边的语句都可以接受
	- int *p1;
	- int * p1;
	- int* p1;

- 指针前面的数据类型指的是指针指向的数据类型

允许void类型的指针  void *p;对一个无类型指针进行解引用前，必须先把它转换为一种适当的数据类型。

星号的两种用途：  
- 第一种是用于创建指针：int *myPointer = &myInt;  
- 第二种是对指针进行解引用：*myPointer = 3998; 这句的意思是对myInt赋值3998.

C++允许多个指针有同样的值

## 指针和数组

数组在计算机中是以一组连续的内存块保存的。**数组的名字其实也是一个指针，指向数组的基地址，就是第一个元素的地址。**
下面两句话做了同样的事情：  
- int *p1 = &myArray[0];  
- int *p2 = myArray;

已经得到数组的基地址的指针p1，如何访问数组的其他元素？p1++，这个运算并不是将地址值简单+1处理，
它是按照指向的数组的数据类型来递增的，也就是+sizeof(int)。

## 结构

**结构(struct)是一种由程序员定义的、由其他变量类型组合而成的数据类型**。定义一个结构的基本语法是
```
struct name
{
	type varName1;
	type varName2;
}; //注意，这里有个分号！
```
当需要处理一些具有多种属性的数据时，结构往往是很好的选择。C++对于一个结构所能包含的变量的个数是没有限制的，
结构的变量成为成员。用"."对结构成员进行赋值。**在C和C++里，指针是无所不能的，也可以指向结构**。

如何通过指针的解引用指向该结构的各个成员？（或者说是通过指针访问各个成员的值）  
- 创建一个指向该结构的指针：FishOil *pJiayu = &Jiayu;  
- 注意，指针的类型必须与指向的地址的变量类型一致，所以pJiayu指针的类型也是FishOil  
- 指针解引用来访问相应的变量值  (*pJiayu).name = "fahiuf";  
- 另一种方法，pJiayu -> name = "fahiuf";std::cout << pJiayu -> name;  

## 传值、传址和传引用

**在默认的情况下，参数只能以值传递的方式给函数。即，被传递到函数的只是变量的值，而不是变量本身**  
**绕开“值传递”的第一种方法是向函数传递变量的地址，也就是说只需要在变量前面加一个“取地址”操作符&就可以了**  
**注意，如果传过去的是地址，在函数中必须要通过“*”对指针进行解引用，除非你有其他用途**
```c++
void changeAge(int age, int newAge) // 传值
{
	age = newAge;
}
int age = 20;
changeAge(age, age+1) // age还是20
```

```c++
void changeAge(int *age, int newAge) // 传址，这里需要把地址解引用
{
	*age = newAge;
}
int age = 20;
changeAge(&age, age+1) // age变为21
```


引用传递和传址的目的是一样的，都是把地址传递给函数，但语法不通更加容易使用了

**例子见Example-12**

## 联合、枚举和类型别名

### 联合（union）
联合和结构有很多相似之处，联合也可以容纳多种不通类型的值，但是它每次只能存储这些值中的某一个。
```c++
//定义联合
union password
{
	unsigned long birthday;
	unsigned short ssn;
	char *per;
}

//创建一个该类型的变量
password pw1;

//赋值
pw1.birthday = 19950101;
pw1.ssn = 12; //当执行这条语句时，上面的birthday会被丢弃。也就是说，它每次只能存储一个值。
```
### 枚举（enum）
**枚举类型用来创建一个可取值列表**

```c++
#include <iostream>
using namespace std;
int main() 
{
	enum weekdays{Monday, Tuesday, Wensday, Thursday, Friday}; //没有引号
	weekdays today;
	today = Monday;
	cout << today << endl; // 0

	today = Tuesday;
	cout << today << endl; // 1 

	switch(today)
	{
		case Monday: break;  
	}
}
```
注意，这里不需要使用引号，因为枚举值不是字符串。编译器会按照各个枚举值在定义时出现的先后顺序把它们与0 ~ n-1的整数
（n是枚举值的总个数）分别关联起来。

使用枚举值类型有两个好处：  
- 它们对变量的可取值加以限制；  
- 它们可以用做switch条件语句的case标号；（因为字符串是不能作为标号用的）  

### 类型别名(typedef)

例如，我们不想用int* 来创建指针，可以向下面这样定义一个类型别名：  
```c++
typedef int* intPointer;
```
之后就可以用下面的方式定义指针了
```c++
intPointer myPointer;
```
## 类和对象

### 基础

**使用对象进行编程是C++的核心，也是C++比C更高级的重要根据之一**

对象的本质是一种新的数据类型。类和结构的区别是结构只有变量，类可以有变量和函数。  
有的程序员喜欢把类的声明和类的函数的定义分别存入两个不同的文件，前者存入.h头文件，后者存入相应的.cpp文件。  
**C++允许在类里声明常量，但是不允许对它进行赋值。**

```c++
class Car
{
	public:
	const float TANKSIZE = 85; // 出错
}
```
绕开这一限制的方法是创建一个静态常量
```c++
class Car 
{
	public:
	static cosnt float FULL_GAS = 85;
}
```
### 构造函数（构造器）

构造器和通用方法的主要区别：  
- 构造器的名字必须和它所在的类的名字一样(大小写保持一致)；  
- 系统在创建某个类的实例时会第一时间自动调用这个类的构造器；  
- 构造器永远不会返回任何值。

创建构造器，需要先把它的声明添加到类里。
```c++
class Car 
{
	Car(void);
}

在结束声明之后开始定义构造器本身：
```c++
Car::Car(void) //不用写void Car::Car(void)
{
	color = "WHITE";
	engine = 'V8";
	wheel = 4;
	gas_tank = FULL_GAS;
}
```
构造对象数组：数组可以是任何一种数据类型，页包括对象。如Car mycar[10];
调用的语法是mycar[x].color;其中x代表数组元素的下标。

**每个类至少有一个构造器，如果没有定义，那么编译器会使用如下语法替你定义一个**
ClassName::ClassName(){}.这是一个空的构造器，除此之外，编译器还会替你创建
一个副本构造器(CopyConstructor)。  

### 析构函数（析构器）

在创建对象时，系统都会自动调用一个特殊的方法，即构造函数；相应的，在销毁一个对象时，系统
也会调用另一个特殊的函数，即析构函数。一般来说，构造器用来完成时限的初始化和准备工作（申请分配内存），
析构器用来完成时候所必须的清理工作（清理内存）。**析构器和构造器有相同的名字，只不过前面多了一个
波浪符"~"前缀**  

```c++
class Car 
{
	Car(void);
	~Car(); //析构器时不带参数的
}
```
在简单的类中，析构器可有可无。在复杂的类中，析构器很重要，没有可能会引起内存泄漏。

### this指针

通过一个例子来认识this指针
```c++
class Human
{
	char fishc;
	Human(char fishc);
}
Human::Human(char fishc)
{
	//fishc = fishc;
	this -> fishc = fishc;
}
注释部分时错误写法，因为编译器不知道哪个是传入的参数fishc，哪个是类的属性fishc。**this指针意思是指向当前类生成的对象**  
这样编译器就知道，赋值符左边是当前对象的属性，右边的是构造器传入来的参数。  

**注意：**  
- 如果代码不存在二义性问题，就不必使用this指针！  

### 类的继承

继承是面对对象编程技术的一个核心概念，它使传统的软件开发模式发生了革命性的变化。
**基类是可以派生出其他类的类，子类是从基类派生出来的类**。  
继承的语法：  
```c++
class SubClass: public SuperClass{}
class Pig : public Animal{}
```

示例见Example-13。
#### 继承机制中的构造函数和析构函数  Example-14
**注意：构造函数先基类后子类，析构函数反之。基类的析构函数将在子类的最后一条语句执行完毕后才被调用**  
```c++
//当构造函数有参数的时候
Animal::Animal(std::string theName)
{
	name = theName;
}
Pig::Pig(std::string theName):Animal(theName)
{}
```
**当调用Pig pig("小猪猪");实际动作发生在Animal()方法里**  


### 访问控制
#### 属性和方法的访问控制
public:可以被任意实体访问  
protected:可以被这个类本身和它的子类访问  
private:只有这个类本身可以访问。使用private的好处是今后修改可以只修改某个类的内部实现，而不必重新修改整个程序。
因为其他代码根本访问不到private保护的内容，所以不会出现“牵一发而动全身”的BUG发生!  	  

在编写你的类定义代码时，应该从public开始，然后是protected，最后是private。  

#### 关于从基类继承来的属性和方法的保护

class Pig:public Animal{}

**C++不仅允许你对在类里定义的方法和属性实施访问控制，还允许你控制子类可以访问基类里的那些属性和方法**  
- public：继承的属性和方法的访问级别不发生任何改变。  
- protected：使得子类外部的代码无法通过子类去访问基类中的public。  
- private：从基类继承来的每一格成员都当成private来对待，这意味着只有这个子类可以使用它从基类继承来的元素。  
一般我们用public既可以。

### 覆盖（重写）方法和重载方法

当我们需要**在基类里提供一个通用的函数，但在它的某个子类里需要修改这个方法的实现**，在C++里覆盖(overriding)就可以做到。
 

**重载机制使你可以定义多个同名的方法，只是它们的输入参数必须不同**。（因为编译器是依靠不同的输入参数来区分不同的方法）。
**继承之后不能重载**。   

### 友元关系

**友元关系是类之间的一种特殊关系，这种关系不仅允许友元访问对方的public方法和属性，还允许友元访问对方的protected和private方法和属性**。

**声明一个友元关系的类：只要在类声明里的某个地方加上一条friend class ** 就可以了**。这条语句可以放在任何地方，放在public、protected和
private的任何段落里都可以。  

### 静态属性和静态方法  Example-15

OOP（面向对象编程）的一个重要特征是用一个对象把数据和对数据处理的方法封装在一起。**使用对象（或者说某个类的实例）来调用方法，每个方法只处理调用它的那个对象所包含的数据，所有的数据都属于同一个对象。**  
C++允许我们把一个或多个成员声明为属于某个类，而不是仅属于该类的对象。**这么做的好处是程序员可以在没有创建任何对象的情况下调用有关的方法**。
**另外一个好处是能够让有关的数据仍在该类的所有对象间共享。**  

创建一个静态属性和静态方法：  
- 只需要在它的声明前加上static保留字即可。  


**静态与非静态的区别：**  
- **静态属性保存在类空间，非静态属性保存在对象空间**   
- **静态属性的访问，通过类访问（::），非静态属性的访问通过对象(->)**  
- 静态方法的访问，通过类访问(::)  
- 如果一个方法内部不操作属于对象空间的属性，那么将其封装成静态方法，通过类来调用，这样效率会快很多  
- 静态方法中不能出现this指针。**因为静态方法不是属于某个特定的对象，而是由全体对象共享的。**     

注意：  
- 静态数据成员不能在类中初始化，实际上类定义只是在描述对象的蓝图，在其中指定初值是不允许的。也不能在类的构造函数中初始化该成员，因为静态数据成员为类的各个对象共享，否则每次创建一个类的对象则静态数据成员都要被重新初始化。静态成员的值对所有的对象是一样的。**静态成员可以被初始化，但只能在类体外进行初始化**（通常在实现文件中进行初始化）。  
- 静态成员函数在类外实现时候无须加static关键字，否则是错误的。  
- 静态成员仍然遵循public，private，protected访问准则。   
- 静态成员函数没有this指针，它不能返回非静态成员，因为除了对象会调用它外，类本身也可以调用。静态成员函数可以直接访问该类的静态数据和函数成员，而访问非静态数据成员必须通过参数传递的方式得到一个对象名，然后通过对象名来访问。  
- **静态成员之间可以相互访问**，包括静态成员函数访问静态数据成员和访问静态成员函数；**非静态成员函数可以任意地访问静态成员函数和静态数据成员；静态成员函数不能访问非静态成员函数和非静态数据成员**；调用静态成员函数，可以用成员访问操作符(.)和(->)为一个类的对象或指向类对象的指针调用静态成员函数;静态成员变量只能被静态成员函数调用，静态成员函数也是由同一类中的所有对象共用，只能调用静态成员变量和静态成员函数。  
- 在使用静态属性时，千万不要忘记为它们分配内存。具体做法是在类声明的外部对静态属性做出声明（就像声明一个变量那样）。  
- 静态方法也可以使用一个普通方法的调用语法来调用，但建议不要这么做，那会让代码变得糟糕，因为不方便和普通方法区分开来。**要使用ClassName::methodName(); 不要使用objectName.methodName();**  

### 虚方法（virtual method）

#### new和delete保留字

在C和C++中，可以在没有创建变量的情况下为有关数据分配内存。也就是直接创建一个指针并让它指向新分配的内存块：  
```c++
int *pointer = new int;
*pointer = 110;
std::cout << *pointer;
delete pointer;
```
最后一步非常必要和关键，因为**C++不会自动释放内存，程序中的每一格new操作都必须有一个与之对应的delete操作**。  

#### 虚方法
声明一个虚方法的语法非常简单，只要在其原型前面加上virtual保留字即可。  
- virtual void play();  

虚方法是继承的，一旦在基类里把某个方法声明为虚方法，在子类里就不可能再把它声明为一个非虚方法了。  

#### 技巧
- 如果拿不准要不要把某个方法声明为虚方法，那么就把它声明为虚方法好了。  
- 在基类里把所有的方法都声明为虚方法会让最终生成的可执行代码的速度变得稍微慢一些，但好处是可以一劳永逸地确保程序的行为符合你的预期。  
- 在实现一个多层次的类继承关系时，最顶级的基类应该只有虚方法。  
- 析构器都是虚方法！从编译的角度看，它们只是普通的方法。如果它们不是虚方法，编译器就会根据它们在编译时的类型而调用那个在基类里定义的
版本（构造器），那样往往会导致内存泄漏。  

### C++的多态

#### 重载、重写、重定义的的区别

##### 1. 重载

​	函数重载是指在同一作用域内（**在同一个类中**），**函数名相同，参数列表不同**的一组函数，这组函数被称为重载函数。重载函数通常用来命名一组功能相似的函数，这样做减少了函数名的数量，避免了名字空间的污染，对于程序的可读性有很大的好处。比如说四则运算中的+函数，可以根据参数不同定义参数为int、str时的加法。被重载的函数不需要有virtual关键字，它们的返回值也有所不同。但调用函数时，会根据参数的类型选择执行哪一个函数。

##### 2. 重写（覆盖）

重写就是override，是指**派生类中定义基类中的虚函数，为多态服务**。特征是**重写的函数与基函数不在一个作用域中（基类和派生类），它们的函数名、函数参数类型、返回值类型都必须相同，但它们的访问修饰符可以不同（private、public、protected），且基类必须是虚函数或纯虚函数**。举个例子，父亲要看电影、儿子也要看电影，但他们看完电影的反应是不一样的（但都得是一种类型的反应，比如说某句话，或者做某件事），他们的函数输入也必须都是电影。父亲看完后print 好看，儿子看完后print 难看，这就是一种虚函数的重写。在函数重写时，往往会加上override关键字声明，以防和重定义混淆。

##### 3. 重定义

重定义也叫隐藏，**重定义是指在不同作用域中，派生类定义了一个和基类函数名字相同、返回值可以不同、参数不同重定义函数**。

- 当基类函数是虚函数时，若子类函数的参数与基类函数相同，那么它叫重写，若参数不同，那么它叫重定义。当基函数和子函数参数不同，并且子函数还用override关键字声明时，编译就会报错。
- 当基类函数不是虚函数时，无论参数是否相同，子类函数都算重定义。

#### 虚函数、纯虚函数、静态联编、动态联编

##### 1. 虚函数、静态联编、动态联编

- 静态联编是指在函数编译时就已确定要调用函数的哪个实现，而动态联编是指在函数执行时才确定调用函数的哪个实现，有些类似tf和pytorch的静态图和动态图。静态联编效率高，动态联编更灵活，**C语言中全都是静态联编**，这也可以说明C中没有对象的概念，也不存在灵活的多态。动态联编还需要和虚函数一起讲。

- 虚函数时为了满足多态的特性，在基类中定义的一种函数。当一个基类类型的指针指向一个派生类的对象时，会优先调用派生类对象中定义的虚函数，而不是基类中的虚函数。比如

```c++
class Cfather
{
public:
virtual void Eat(){cout<<"Im your father"<<endl;}
void Move(){cout<<"father can move, kid cant do it";}
private:
};
class CChild : public Cfather
{
public:
virtual void Eat(){cout<<"Im your kid"<<endl;}
private:
};
Cfather m_father;
CChild m_child;
Cfather *p ;  // 注意，此时指针类型是父类
p = &m_father ; //指向基类对象的父类类型指针
p->Eat();    //输出"Im your father"
p = &m_child;
p->Eat();    // 输出"Im your kid"
//如果子类没有重写此函数时，则还是调用父类中的
p->Move(); //输出 "father can move, kid cant do it"
```

在这里，指向子类对象的指针调用Eat函数时就是动态联编，直到运行时才根据对象m_child的类型确定调用哪个函数实现。

##### 2. 纯虚函数

纯虚函数比较简单，类似于Java中的接口函数。它在基类中不允许被定义，但要求它的派生类必须实现纯虚函数，有纯虚函数的类也叫做**抽象类**（抽象类不能生成对象）。纯虚函数的意义在于它代表着一种抽象的对象，比如生物，生物可以由人、老虎等继承，但是它本身缺少实际的意义，所以生物会作为一个抽象类。要定义纯虚函数，只需要在虚函数的函数体后加一个“=0”即可，比如

```c++
class Creature{
      public:
          virtual void speak() = 0;//纯虚函数, print生物叫声，但“生物”本身是没有叫声的
}
class Dog{
  		public:
  				virtual void speak(){cout<<"汪汪汪！"<<endl;}
}
class Cat{
  		public:
  				virtual void speak(){cout<<"喵喵喵！"<<endl;}
}
```

### 抽象方法（abstract method，纯虚函数）
把某个方法声明为一个抽象方法等于告诉编译器**这个方法必不可少，但是在这个基类里还不能为它提供一个实现**  
纯虚函数的定义：在声明一个虚函数的基础上，在原型的末尾加上“=0”。告诉编译器不用浪费时间在这个类里寻找这个方法的实现。  

### 多态性  
**多态性是OOP的重要特征之一**  
**多态性是指用一个名字定义不同的函数，调用同一个名字的函数，却执行不同的操作，从而实现“一个结构，多种方法”**。  

多态是如何实现绑定的？  
- 编译的实时性：通过重载实现；  
- 运行时的多态性：通过虚函数实现；  
编译时的多态性特点是运行速度快，运行时的多态性是高度灵活和抽象。  


**成员函数的重载、覆盖和隐藏的区别：**  
- 成员函数重载的特征：
  - 相同的范围（在同一个类中）；  
  - 函数名字相同；  
  - 参数不同；   
  - virtual关键字可有可无。  
- 覆盖是指派生类的函数覆盖基类函数，特征：  
  - 不同的范围（分别位于派生类和基类）；  
  - 函数名字相同；  
  - 参数相同；  
  - 基类函数必须有virtual关键字。  
- 


析构函数都是虚方法：  
- 析构函数是为了释放内存资源的，如果析构函数不被调用会造成内存泄漏。  
- **析构函数都是虚方法是为了当一个基类的指针删除一个派生类的对象时，派生类的析构函数可以被正确调用。**  
- 当类里面有虚函数时，编译器会给类添加一个虚函数表，里边存放着虚函数指针。**为了节省资源，只有当一个类被用来作为基类的时候，我们才把析构函数写成虚函数**。 （因为继承虚函数的函数会自动变为虚函数，所以只需要把基类的析构函数写成虚函数） 
  
### 运算符重载
**运算符重载的方法是定义一个重载运算符的函数，在需要执行被重载的运算符时，系统就自动调用该函数，以实现相应的运算**。也就是说运算符重载是通过定义函数实现的，运算符重载实质上是函数的重载。

重载运算符的函数一般格式如下：
```c++
函数类型 operator 运算符名称（形参）
{
	对运算符的重载处理
}

int operator+(int a, int b)
{
	return (a-b);
}
```
- C++不允许用户自己定义新的运算符，只能对已有的C++运算符进行重载。下面五个运算符不允许重载：    
	- .（成员访问运算符）  
	- .*（成员指针访问运算符）  
	- ::（域运算符）  
	- sizeof（尺寸运算符）  
	- ?:（条件运算符）  
- 重载不能改变运算符运算对象个数；  
- 重载不能改变运算符的优先级别；  
- 重载不能改变运算符的结合性；  
- 重载运算符的函数不能有默认的参数；  
- 重载运算符必须和用户自定义类型的对象一起使用，其参数至少应该有一个是类对象或类对象的引用。也就是说，参数不能全部都是C++的标准类型，这样约定是为了防止用户修改用于标准类型结构的运算符的性质。  

运算符重载除了可以作为累的成员函数外，还可以是非成员函数：放在类外，做Complex类（举个例子，复数类）的友元函数存在。为什么要把运算符函数作为友元函数呢？因为运算符函数要访问Complex类对象的成员，如果运算符函数不是Complex类的友元函数，而是一个普通函数，它是没有权限访问Complex类的私有成员的。由于友元的使用会破坏类的封装，因此从原则上说，要尽量将运算符函数作为成员函数。  
  

